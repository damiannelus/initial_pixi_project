<!doctype html>
<meta charset="utf-8">
<title>Displaying the canvas</title>

<body>
    <script src="js/pixi.min.js"></script>
    <script>

        //Create a Pixi Application
        let app = new PIXI.Application({
            antialiasing: true,
            transparent: false,
            resolution: 1
        }
        );

        let Application = PIXI.Application,
            loader = PIXI.loader,
            resources = PIXI.loader.resources,
            Sprite = PIXI.Sprite;

        //Add the canvas that Pixi automatically created for you to the HTML document
        document.body.appendChild(app.view);

        //If you want to make the canvas fill the entire window, you can apply this
        //CSS styling:
        app.renderer.view.style.position = "absolute"
        app.renderer.view.style.width = window.innerWidth + "px";
        app.renderer.view.style.height = window.innerHeight + "px";
        app.renderer.view.style.display = "block";

        //The `renderer.view` is just an ordinary `<canvas>` element.
        //Here's how you can reference to add an optional dashed 
        //border around the canvas 
        // app.renderer.view.style.border = "1px dashed black";

        //To resize the canvas
        app.renderer.resize(window.innerWidth, window.innerHeight);

        //To change the background color
        app.renderer.backgroundColor = 0x6AA84F;
        let asset_uris = ["images/rocket_1.png", "images/enemy_shuttle_1.png", "images/enemy_shuttle_3.png", "images/enemy_shuttle_2.png"]
        // Add sprite for main spaceship
        //load an image and run the `setup` function when it's done
        // TODOs the below implementation sucks
        PIXI.loader
            .add(asset_uris[0])
            .add(asset_uris[1])
            .add(asset_uris[2])
            .add(asset_uris[3])
            .load(setup);

        let left = keyboard("ArrowLeft"),
            up = keyboard("ArrowUp"),
            right = keyboard("ArrowRight"),
            down = keyboard("ArrowDown"),
            space = keyboard("Space");

        let main_rocket;
        let enemy_rockets = [];
        let enemies = new PIXI.Container();

        //This `setup` function will run when the image has loaded
        function setup() {

            //Create the main rocket sprite
            initiateMainRocketSprite();

            // create enemy rockets
            initiateEnemyRocketSprites();

            state = play;
            //Start the game loop by adding the `gameLoop` function to
            //Pixi's `ticker` and providing it with a `delta` argument.
            app.ticker.add(delta => gameLoop(delta));
        }

        function gameLoop(delta) {
            state(delta)
        }

        function play(delta) {
            // Update the velocity:

            //Move the cat 1 pixel:
            // let steering_wheel = Math.random();
            // main_rocket.x = steering_wheel > 0.5 ? main_rocket.x + main_rocket.vx : main_rocket.x - main_rocket.vx;
            // main_rocket.x = main_rocket.x < 0 ? 0 : main_rocket.x
            // main_rocket.y = steering_wheel > 0.5 ? main_rocket.y + main_rocket.vy : main_rocket.y - main_rocket.vy;
            // main_rocket.y = main_rocket.y < 0 ? 0 : main_rocket.y

            // TODO move enemies
            // TODO continue https://github.com/kittykatattack/learningPixi#using-a-particlecontainer-to-group-sprites
            // Move
            if (right.isDown) {
                main_rocket.x += main_rocket.vx
            } else if (left.isDown) {
                main_rocket.x -= main_rocket.vx
            }

            //Rotate
            if (down.isDown) {
                rotateMainRocket("ccw");
            } else if (up.isDown) {
                rotateMainRocket("cw");
            }
        }

        function rotateMainRocket(direction) {
            main_rocket.rotation = direction == "cw" ? main_rocket.rotation + 0.1 : main_rocket.rotation - 0.1
        }

        // TODO: prob. better way of managing keyboard
        function keyboard(value) {
            let key = {};
            key.value = value;
            key.isDown = false;
            key.isUp = true;
            key.press = undefined;
            key.release = undefined;
            //The `downHandler`
            key.downHandler = event => {
                if (event.key === key.value) {
                    if (key.isUp && key.press) key.press();
                    key.isDown = true;
                    key.isUp = false;
                    event.preventDefault();
                }
            };

            //The `upHandler`
            key.upHandler = event => {
                if (event.key === key.value) {
                    if (key.isDown && key.release) key.release();
                    key.isDown = false;
                    key.isUp = true;
                    event.preventDefault();
                }
            };

            //Attach event listeners
            const downListener = key.downHandler.bind(key);
            const upListener = key.upHandler.bind(key);

            window.addEventListener(
                "keydown", downListener, false
            );
            window.addEventListener(
                "keyup", upListener, false
            );

            // Detach event listeners
            key.unsubscribe = () => {
                window.removeEventListener("keydown", downListener);
                window.removeEventListener("keyup", upListener);
            };

            return key;
        }


        function initiateMainRocketSprite() {
            main_rocket = new Sprite(resources[asset_uris[0]].texture);
            main_rocket.anchor.x = 0.5;
            main_rocket.anchor.y = 0.5;
            main_rocket.vx = 1;
            main_rocket.vy = 1;
            main_rocket.width = 30;
            main_rocket.height = 120;

            // position sprite
            main_rocket.x = Math.ceil((Math.random() * (window.innerWidth) / 2 + (window.innerWidth) / 4));
            main_rocket.y = Math.ceil((Math.random() * (window.innerHeight) / 4 + (window.innerHeight) / 2));

            //Add the mr to the stage
            app.stage.addChild(main_rocket);
            
        }

        function initiateEnemyRocketSprites() {
            for (let index = 1; index < asset_uris.length; index++) {
                enemy_rockets.push(new Sprite(resources[asset_uris[index]].texture))
                enemy_rockets[index - 1].x = Math.ceil((Math.random() * (window.innerWidth) / 2 + (window.innerWidth) / 4));
                enemy_rockets[index - 1].y = Math.ceil((Math.random() * (window.innerHeight) / 4));
                enemy_rockets[index - 1].vx = 1;
                enemy_rockets[index - 1].vy = 1;
                enemy_rockets[index - 1].width = 30;
                enemy_rockets[index - 1].height = 120;
                enemies.addChild(enemy_rockets[index - 1]);
            }

            app.stage.addChild(enemies);
        }
    </script>
</body>