<!-- TUTORIAL LINK: https://github.com/kittykatattack/learningPixi#using-a-particlecontainer-to-group-sprites -->
<!doctype html>
<meta charset="utf-8">
<title>Displaying the canvas</title>

<body>
    <script src="js/pixi.min.js"></script>
    <script src="js/bump.js"></script>
    <script src="js/keyboard.js"></script>
    <script src="js/init_stage.js"></script>
    <script>
        // TODO: split into components/smaller files
        // 

        //Create a Pixi Application
        let app = new PIXI.Application({
            antialiasing: true,
            transparent: false,
            resolution: 1
        }
        );

        let Application = PIXI.Application,
            loader = PIXI.loader,
            resources = PIXI.loader.resources,
            Sprite = PIXI.Sprite;

        //Add the canvas that Pixi automatically created for you to the HTML document
        document.body.appendChild(app.view);

        //If you want to make the canvas fill the entire window, you can apply this
        //CSS styling:
        app.renderer.view.style.position = "absolute"
        app.renderer.view.style.width = window.innerWidth + "px";
        app.renderer.view.style.height = window.innerHeight + "px";
        app.renderer.view.style.display = "block";

        //The `renderer.view` is just an ordinary `<canvas>` element.
        //Here's how you can reference to add an optional dashed 
        //border around the canvas 
        // app.renderer.view.style.border = "1px dashed black";

        //To resize the canvas
        app.renderer.resize(window.innerWidth, window.innerHeight);

        //To change the background color
        app.renderer.backgroundColor = 0x6AA84F;
        let asset_uris = ["rocket_1.png", "enemy_shuttle_1.png", "enemy_shuttle_3.png", "enemy_shuttle_2.png"];
        let bomb_uri = ["bomb.png"];

        // Add sprite for main spaceship
        //load an image and run the `setup` function when it's done
        PIXI.loader
            .add("images/texture_atlas.json")
            .load(setup);

        let left = keyboard("ArrowLeft"),
            up = keyboard("ArrowUp"),
            right = keyboard("ArrowRight"),
            down = keyboard("ArrowDown"),
            space = keyboard("ShiftLeft");

        let main_rocket;
        let enemy_rockets = [];
        let enemies = new PIXI.Container();
        let bombs = [];
        let b = new Bump(PIXI);

        //This `setup` function will run when the image has loaded
        function setup() {

            //Create the main rocket sprite
            initiateMainRocketSprite();

            // create enemy rockets
            initiateEnemyRocketSprites();

            state = play;
            //Start the game loop by adding the `gameLoop` function to
            //Pixi's `ticker` and providing it with a `delta` argument.
            app.ticker.add(delta => gameLoop(delta));
        }

        function gameLoop(delta) {
            state(delta)
        }

        function play(delta) {
            moveEnemies();

            // Move the main spaceship
            if (right.isDown) {
                main_rocket.x += main_rocket.vx
            } else if (left.isDown) {
                main_rocket.x -= main_rocket.vx
            }

            // move bombs
            moveBombs();

            // check enemies x bombs colisions
            checkEnemiesHits();

            destroyBombsOutsideStage();

            main_rocket.shot_delay = main_rocket.shot_delay > 0 ? main_rocket.shot_delay - 1 : 0

            // Shoots 
            if (up.isDown) {
                shotABomb()
            }
        }

        function rotateMainRocket(direction) {
            main_rocket.rotation = direction == "cw" ? main_rocket.rotation + (Math.PI / 20) : main_rocket.rotation - (Math.PI / 20)
        }

        function moveEnemies() {
            let steering_wheel = Math.random();
            console.log('steering_wheel :>> ', steering_wheel);
            let xp = steering_wheel > 0.5 ? enemies.x + enemies.vx : enemies.x - enemies.vx;
            // xp = enemies.xp < 0 ? 0 : enemies.x
            let yp = (Math.ceil(steering_wheel * 100) % 2) == 0 ? enemies.y + enemies.vy : enemies.y - enemies.vy;
            // yp = enemies.yp < 0 ? 0 : enemies.y
            console.log('xp :>> ', xp);
            console.log('yp :>> ', yp);
            enemies.position.set(xp, yp);
        }

        function shotABomb() {
            if (main_rocket.shot_delay == 0) {
                main_rocket.shot_delay = 10;
                console.log("shoot a bomb at: " + main_rocket.x + " x " + main_rocket.y)
                let tmp = new Sprite(resources["images/texture_atlas.json"].textures[bomb_uri])
                tmp.scale.set(0.1);
                tmp.x = main_rocket.x + (main_rocket.width - tmp.width) / 2;
                tmp.y = main_rocket.y;
                tmp.anchor.x = 0;
                tmp.anchor.y = 0;
                tmp.vx = 1;
                tmp.vy = 1;
                bombs.push(tmp);
                app.stage.addChild(tmp);
            }
        }

        function moveBombs() {
            bombs.forEach(element => {
                // element.x -= element.vx;
                element.y -= element.vy;
            });
        }

        function destroyBombsOutsideStage() {
            if (bombs.length > 0) {
                for (let index = 0; index < bombs.length; index++) {
                    if (bombs[index].y < 0) {
                        app.stage.removeChild(bombs[index]);
                        bombs.shift();
                    }

                }
            }
        }

        function checkEnemiesHits() {
            bombs.forEach(bomb => {
                enemy_rockets.forEach((er, index) => {
                    if (b.hit(bomb, er)) {
                        enemies.removeChild(er);
                        enemy_rockets.splice(index, 1)
                        console.log("rocket to be destroyed: " + index);
                    }
                });
            });
        }

        // function hitTestRectangle(bomb, enemy) {

        //     //Define the variables we'll need to calculate
        //     let hit, combinedHalfWidths, combinedHalfHeights, vx, vy;

        //     //hit will determine whether there's a collision
        //     hit = false;

        //     //Find the center points of each sprite
        //     bomb.centerX = bomb.x + bomb.width / 2;
        //     bomb.centerY = bomb.y + bomb.height / 2;
        //     enemy.centerX = enemy.x + enemy.width / 2;
        //     enemy.centerY = enemy.y + enemy.height / 2;

        //     //Find the half-widths and half-heights of each sprite
        //     enemy.halfWidth = enemy.width / 2;
        //     enemy.halfHeight = enemy.height / 2;

        //     //Calculate the distance vector between the sprites
        //     dx = bomb.centerX - enemy.centerX;
        //     dy = bomb.centerY - enemy.centerY;


        //     //Check for a collision on the x axis
        //     if (Math.abs(dx) < enemy.halfWidth) {
        //         // console.log("vx : " + Math.abs(vx) + " enemy.halfWidth: " + enemy.halfWidth)
        //         console.log("vy : " + Math.abs(vy) + " enemy.halfHeight: " + enemy.halfHeight)
        //         //A collision might be occurring. Check for a collision on the y axis
        //         if (Math.abs(dy) < enemy.halfHeight) {
        //             console.log("hit: true")
        //             //There's definitely a collision happening
        //             hit = true;
        //         } else {

        //             //There's no collision on the y axis
        //             hit = false;
        //         }
        //     } else {

        //         //There's no collision on the x axis
        //         hit = false;
        //     }

        //     //`hit` will be either `true` or `false`
        //     return hit;
        // };

        function boxesIntersect(a, b) {
            var ab = a.getBounds();
            var bb = b.getBounds();
            console.log('ab :>> ', ab);
            console.log('bb :>> ', bb);
            return ab.x + ab.width > bb.x && ab.x < bb.x + bb.width && ab.y + ab.height > bb.y && ab.y < bb.y + bb.height;
        }
    </script>
</body>